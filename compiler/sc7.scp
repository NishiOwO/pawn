/*  Pawn compiler - Peephole optimizer "sequences" strings (plain
 *                  and compressed formats)
 *
 *  Copyright (c) CompuPhase, 2000-2016
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not
 *  use this file except in compliance with the License. You may obtain a copy
 *  of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 *  License for the specific language governing permissions and limitations
 *  under the License.
 *
 *  Version: $Id: sc7.sch 7006 2023-10-09 08:09:26Z thiadmer $
 */

/* Special characters in the strings of this file:
 *  %1 to %5    Parameters that are replaced, the parameters should be numerical
 *              (hexadecimal) values (exceptionally, an alphanumeric symbol).
 *  %0          A parameter that is replaced with its packed value (so on a
 *              32-bit system, 00001234 gets replaced by 1234).
 *  -           In front of a parameter, - means that the parameter is replaced
 *              by the negated value from the source; this token is valid only
 *              in the replacement string.
 *  +           Between two parameters, + means that the parameters are replaced
 *              by the sum; this token is valid only in the replacement string.
 *  ~           In front of a parameter, and optional space, which should precede
 *              an optional variable.
 *  #           In front of a literal value, the expanded hexadecimal version of
 *              that literal value (so #5 becomes 00000005 on a 32-bit system);
 *              this token is valid only in the replacement string.
 */

SC_FUNC int strexpand(char *dest, const unsigned char *source, int maxlen, const unsigned char pairtable[128][2]);

#define SCPACK_TERMINATOR ,     /* end each section with a comma */

#define SCPACK_TABLE sequences_table
/*-*SCPACK start of pair table, do not change or remove this line */
const unsigned char sequences_table[128][2] = {
  {105,32}, {114,128}, {112,129}, {46,130}, {49,33}, {37,132}, {32,37}, {97,100}, {115,104}, {117,136}, {112,137}, {46,115}, {32,133}, {50,33}, {59,36}, {108,111},
  {143,135}, {97,108}, {145,116}, {46,146}, {46,112}, {105,33}, {131,133}, {114,33}, {131,37}, {97,151}, {112,153}, {142,154}, {115,116}, {144,139}, {46,99}, {114,149},
  {148,159}, {152,141}, {48,33}, {135,100}, {147,33}, {134,141}, {110,156}, {111,166}, {99,167}, {112,111}, {169,112}, {138,114}, {112,33}, {120,172}, {101,173}, {142,174},
  {138,160}, {134,162}, {134,51}, {170,164}, {147,140}, {134,49}, {157,161}, {126,37}, {178,33}, {103,33}, {104,185}, {99,186}, {120,187}, {163,114}, {46,135}, {122,101},
  {190,114}, {191,114}, {101,113}, {155,138}, {168,150}, {46,149}, {110,100}, {105,110}, {52,33}, {32,35}, {199,99}, {101,99}, {100,203}, {155,171}, {140,175}, {114,101},
  {207,102}, {157,150}, {53,33}, {108,208}, {163,33}, {189,150}, {194,33}, {136,108}, {138,109}, {134,200}, {144,150}, {134,50}, {106,193}, {105,100}, {115,103}, {115,108},
  {221,120}, {215,158}, {181,165}, {147,165}, {176,182}, {117,198}, {111,229}, {98,230}, {193,111}, {231,115}, {180,182}, {181,219}, {211,139}, {220,140}, {144,161}, {233,184},
  {179,212}, {139,140}, {158,140}, {171,109}, {152,162}, {198,33}, {170,160}, {156,111}, {247,114}, {97,245}, {183,50}, {235,178}, {183,51}, {134,48}, {139,177}
};
/*-*SCPACK end of pair table, do not change or remove this line */

typedef struct {
  const char *find;
  const char *replace;
  short opc,arg;        /* number of opcodes/arguments saved (may be negative!) */
} SEQUENCE;
static const char separator_macro[] = {sOPTIMIZE_MACRO,'\0'};
static const char separator_full[] = {sOPTIMIZE_FULL,'\0'};
static const SEQUENCE sequences_cmp[] = {
  /* A very common sequence in four varieties
   *    load.s.pri %1           load.s.pri %2
   *    push.pri                load.s.alt %1
   *    load.s.pri %2           -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.pri %1             load.s.pri %2
   *    push.pri                load.alt %1
   *    load.s.pri %2           -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.s.pri %1           load.pri %2
   *    push.pri                load.s.alt %1
   *    load.pri %2             -
   *    pop.alt                 -
   *    --------------------------------------
   *    load.pri %1             load.pri %2
   *    push.pri                load.alt %1
   *    load.pri %2             -
   *    pop.alt                 -
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!load.s.alt %1!",
    #else
      "\321\344\263",
      "\266\235\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!load.alt %1!",
    #else
      "\332\344\263",
      "\266\220\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!load.s.alt %1!",
    #else
      "\321\260\356\263",
      "\356\235\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!load.alt %1!",
    #else
      "\332\260\356\263",
      "\356\220\264",
    #endif
    4-2, 2-2
  },
  /* (#1#) The above also occurs with "addr.pri" (array
   * indexing) as the first line; so that adds 2 cases.
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "addr.alt %1!load.s.pri %2!",
    #else
      "\325\344\263",
      "\275\352",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.pri %2!pop.alt!",
      "addr.alt %1!load.pri %2!",
    #else
      "\325\260\356\263",
      "\275\264\356",
    #endif
    4-2, 2-2
  },
  /* And the same sequence with const.pri as either the first
   * or the second load instruction: four more cases.
   */
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!pop.alt!",
      "load.s.pri %2!const.alt %1!",
    #else
      "\304\344\263",
      "\266\250\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.pri %2!pop.alt!",
      "load.pri %2!const.alt %1!",
    #else
      "\304\260\356\263",
      "\356\250\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!const.pri %2!pop.alt!",
      "const.pri %2!load.s.alt %1!",
    #else
      "\321\260\250\241\263",
      "\250\241\235\264",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!const.pri %2!pop.alt!",
      "const.pri %2!load.alt %1!",
    #else
      "\332\260\250\241\263",
      "\250\241\220\264",
    #endif
    4-2, 2-2
  },
  /* The same as above, but now with "addr.pri" (array
   * indexing) on the first line and const.pri on
   * the second.
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!const.pri %2!pop.alt!",
      "addr.alt %1!const.pri %2!",
    #else
      "\325\260\250\241\263",
      "\275\264\250\241",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!zero.pri!pop.alt!",
      "addr.alt %1!zero.pri!",
    #else
      "\325\260\350\240\263",
      "\275\264\350\240",
    #endif
    4-2, 1-1
  },
  /* The same as above, but now with "addr.pri" twice
   * (array copying/comparison).
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!addr.pri %2!pop.alt!",
      "addr.alt %1!addr.pri %2!",
    #else
      "\325\260\275\241\263",
      "\275\264\275\241",
    #endif
    4-2, 2-2
  },
  /* ??? add references */
  /* Chained relational operators can contain sequences like:
   *    xchg                    load.s.pri %1
   *    push.pri                -
   *    load.s.pri %1           -
   *    pop.alt                 -
   * The above also accurs for "load.pri" and for "const.pri",
   * so add another two cases.
   */
  {
    #ifdef SCPACK
      "xchg!push.pri!load.s.pri %1!pop.alt!",
      "load.s.pri %1!",
    #else
      "\274\260\321\263",
      "\321",
    #endif
    4-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!push.pri!load.pri %1!pop.alt!",
      "load.pri %1!",
    #else
      "\274\260\332\263",
      "\332",
    #endif
    4-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!push.pri!const.pri %1!pop.alt!",
      "const.pri %1!",
    #else
      "\274\260\304\263",
      "\304",
    #endif
    4-1, 1-1
  },
  /* More optimizations for chained relational operators; the
   * continuation sequences can be simplified if they turn out
   * to be termination sequences:
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   pop.alt
   *    swap.alt                and
   *    and                     ;$exp
   *    pop.alt                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   pop.alt
   *    swap.alt                and
   *    and                     jzer %1
   *    pop.alt                 -
   *    jzer %1                 -
   */
  {
    #ifdef SCPACK
      "xchg!sgrtr!swap.alt!and!pop.alt!;$exp!",
      "sless!pop.alt!and!;$exp!",
    #else
      "\274\336rt\227swap\244\371\263\257",
      "\337ess!\263\371\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sless!swap.alt!and!pop.alt!;$exp!",
      "sgrtr!pop.alt!and!;$exp!",
    #else
      "\274\337ess!swap\244\371\263\257",
      "\336rt\227\263\371\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!swap.alt!and!pop.alt!;$exp!",
      "sleq!pop.alt!and!;$exp!",
    #else
      "\274\336\326swap\244\371\263\257",
      "\337\326\263\371\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sleq!swap.alt!and!pop.alt!;$exp!",
      "sgeq!pop.alt!and!;$exp!",
    #else
      "\274\337\326swap\244\371\263\257",
      "\336\326\263\371\257",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgrtr!swap.alt!and!pop.alt!jzer %1!",
      "sless!pop.alt!and!jzer %1!",
    #else
      "\274\336rt\227swap\244\371\263\355",
      "\337ess!\263\371\355",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sless!swap.alt!and!pop.alt!jzer %1!",
      "sgrtr!pop.alt!and!jzer %1!",
    #else
      "\274\337ess!swap\244\371\263\355",
      "\336rt\227\263\371\355",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!swap.alt!and!pop.alt!jzer %1!",
      "sleq!pop.alt!and!jzer %1!",
    #else
      "\274\336\326swap\244\371\263\355",
      "\337\326\263\371\355",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sleq!swap.alt!and!pop.alt!jzer %1!",
      "sgeq!pop.alt!and!jzer %1!",
    #else
      "\274\337\326swap\244\371\263\355",
      "\336\326\263\371\355",
    #endif
    5-3, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgrtr!;$exp!",
      "sless!;$exp!",
    #else
      "\274\336rt\227\257",
      "\337ess!\257",
    #endif
    2-1, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sless!;$exp!",
      "sgrtr!;$exp!",
    #else
      "\274\337ess!\257",
      "\336rt\227\257",
    #endif
    2-1, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!;$exp!",
      "sleq!;$exp!",
    #else
      "\274\336\326\257",
      "\337\326\257",
    #endif
    2-1, 0-0
  },
  {
    #ifdef SCPACK
      "xchg!sleq!;$exp!",
      "sgeq!;$exp!",
    #else
      "\274\337\326\257",
      "\336\326\257",
    #endif
    2-1, 0-0
  },
  /* The entry to chained operators is also opt to optimization
   *    load.s.pri %1           load.s.pri %2
   *    load.s.alt %2           load.s.alt %1
   *    xchg                    -
   *    --------------------------------------
   *    load.s.pri %1           load.pri %2
   *    load.alt %2             load.s.alt %1
   *    xchg                    -
   *    --------------------------------------
   *    load.s.pri %1           const.pri %2
   *    const.alt %2            load.s.alt %1
   *    xchg                    -
   *    --------------------------------------
   * and all permutations...
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!load.s.alt %1!",
    #else
      "\321\235\343\274",
      "\266\235\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!load.alt %2!xchg!",
      "load.pri %2!load.s.alt %1!",
    #else
      "\321\220\343\274",
      "\356\235\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!const.alt %2!xchg!",
      "const.pri %2!load.s.alt %1!",
    #else
      "\321\250\343\274",
      "\250\241\235\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!load.alt %1!",
    #else
      "\332\235\343\274",
      "\266\220\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!xchg!",
      "load.pri %2!load.alt %1!",
    #else
      "\332\220\343\274",
      "\356\220\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!xchg!",
      "const.pri %2!load.alt %1!",
    #else
      "\332\250\343\274",
      "\250\241\220\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.s.alt %2!xchg!",
      "load.s.pri %2!const.alt %1!",
    #else
      "\304\235\343\274",
      "\266\250\264",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!xchg!",
      "load.pri %2!const.alt %1!",
    #else
      "\304\220\343\274",
      "\356\250\264",
    #endif
    3-2, 2-2
  },
  /* some sequences where PRI is moved to ALT can be optimized
   * further when considering what follows
   *    xchg                    const.alt %1
   *    const.pri %1            -
   *    xchg                    -
   * (also for load.s.pri and load.pri)
   *    --------------------------------------
   *    lref.pri %1             lref.alt %1
   *    xchg                    [load.pri %2]
   *    [load.pri %2]           -
   * (where [load.pri %2] may also be another operatrion loading PRI)
   */
  {
    #ifdef SCPACK
      "xchg!const.pri %1!xchg!",
      "const.alt %1!",
    #else
      "\274\304\274",
      "\250\264",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.pri %1!xchg!",
      "load.alt %1!",
    #else
      "\274\332\274",
      "\220\264",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.s.pri %1!xchg!",
      "load.s.alt %1!",
    #else
      "\274\321\274",
      "\235\264",
    #endif
    3-1, 1-1
  },
  /* ----- */
  {
    #ifdef SCPACK
      "lref.pri %1!xchg!load.pri %2!",
      "lref.alt %1!load.pri %2!",
    #else
      "\323\226\274\356",
      "\323\264\356",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.pri %1!xchg!load.s.pri %2!",
      "lref.alt %1!load.s.pri %2!",
    #else
      "\323\226\274\266",
      "\323\352",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.pri %1!xchg!const.pri %2!",
      "lref.alt %1!const.pri %2!",
    #else
      "\323\226\274\250\241",
      "\323\264\250\241",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!xchg!load.pri %2!",
      "lref.s.alt %1!load.pri %2!",
    #else
      "\354\226\274\356",
      "\354\264\356",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!xchg!load.s.pri %2!",
      "lref.s.alt %1!load.s.pri %2!",
    #else
      "\354\226\274\266",
      "\354\352",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!xchg!const.pri %2!",
      "lref.s.alt %1!const.pri %2!",
    #else
      "\354\226\274\250\241",
      "\354\264\250\241",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "lref.s.pri %1!push.pri!lref.s.pri %2!pop.alt!",
      "lref.s.alt %1!lref.s.pri %2!",
    #else
      "\354\226\260\354\241\263",
      "\354\264\354\241",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "push.pri!lref.s.pri %1!pop.alt!",
      "xchg!lref.s.pri %1!",
    #else
      "\260\354\226\263",
      "\274\354\226",
    #endif
    3-2, 1-1
  },

  /* For packed arrays, array access can be optimized (packed arrays
   * do not take advantage of the LIDX or IDXADDR instructions).
   *    addr.pri %1             addr.alt %1
   *    push.pri                load.s.pri %2
   *    load.s.pri %2           bounds %3
   *    bounds %3               -
   *    pop.alt                 -
   *
   * Notes (additional cases):
   * 1. instruction addr.pri can also be const.pri (for
   *    global arrays)
   * 2. the bounds instruction can be absent, but that
   *    case is already handled (see #1#)
   */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!pop.alt!",
      "addr.alt %1!load.s.pri %2!bounds %3!",
    #else
      "\325\344\357\263",
      "\275\352\357",
    #endif
    5-3, 3-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!pop.alt!",
      "const.alt %1!load.s.pri %2!bounds %3!",
    #else
      "\304\344\357\263",
      "\250\352\357",
    #endif
    5-3, 3-3
  },
  /* During a calculation, the intermediate result must sometimes
   * be moved from PRI to ALT, like in:
   *    push.pri                xchg
   *    load.s.pri %1           load.s.pri %1
   *    pop.alt                 -
   *
   * The above also accurs for "load.pri" and for "const.pri",
   * so add another two cases.
   */
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!pop.alt!",
      "xchg!load.s.pri %1!",
    #else
      "\260\321\263",
      "\274\321",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!load.pri %1!pop.alt!",
      "xchg!load.pri %1!",
    #else
      "\260\332\263",
      "\274\332",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!pop.alt!",
      "xchg!const.pri %1!",
    #else
      "\260\304\263",
      "\274\304",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!zero.pri!pop.alt!",
      "xchg!zero.pri!",
    #else
      "\260\350\240\263",
      "\274\350\240",
    #endif
    3-2, 0-0
  },
  /* An even simpler PUSH/POP optimization (occurs in
   * switch statements):
   *    push.pri                xchg
   *    pop.alt                 -
   * Note that it is somewhat dangerous to do this, as
   * the original sequence keeps PRI and the new sequence
   * destroys it.
   */
  {
    #ifdef SCPACK
      "push.pri!pop.alt!",
      "xchg!",
    #else
      "\260\263",
      "\274",
    #endif
    2-1, 0-0
  },
  /* Redundant pushes (happens in some array operations)
   *    pop.alt                -
   *    push.alt               -
   */
  {
    #ifdef SCPACK
      "pop.alt!push.alt!",
      ";!",
    #else
      "\263\212\244",
      ";!",
    #endif
    2-0, 0-0
  },
  /* Some simple arithmetic sequences
   */
  {
    #ifdef SCPACK
      "xchg!load.s.pri %1!add!",
      "load.s.alt %1!add!",
    #else
      "\274\321\324",
      "\235\264\324",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.pri %1!add!",
      "load.alt %1!add!",
    #else
      "\274\332\324",
      "\220\264\324",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!const.pri %1!add!",
      "const.alt %1!add!",
    #else
      "\274\304\324",
      "\250\264\324",
    #endif
    3-2, 1-1
  },
  /* References with a default value generate new cells on the heap
   * dynamically. That code often ends with:
   *    xchg                    push.alt
   *    push.pri                -
   */
  {
    #ifdef SCPACK
      "xchg!push.pri!",
      "push.alt!",
    #else
      "\274\260",
      "\212\244",
    #endif
    2-1, 0-0
  },
  /* Test for zero (common case, especially for strings)
   * E.g. the test expression of: "for (i=0; str{i}!=0; ++i)"
   *
   *    zero.alt                jzer %1
   *    eq                      -
   *    jnz %1                  -
   *    --------------------------------------
   *    zero.alt                jnz %1
   *    eq                      -
   *    jzer %1                 -
   *    --------------------------------------
   *    zero.alt                jzer %1
   *    neq                     -
   *    jzer %1                 -
   */
  {
    #ifdef SCPACK
      "zero.alt!eq!jnz %1!",
      "jzer %1!",
    #else
      "\350\244\326jnz\214",
      "\355",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.alt!eq!jzer %1!",
      "jnz %1!",
    #else
      "\350\244\326\355",
      "jnz\214",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.alt!neq!jzer %1!",
      "jzer %1!",
    #else
      "\350\244n\326\355",
      "\355",
    #endif
    3-1, 1-1
  },
  /* Array comparison has a NOT instruction that can sometimes be optimized away
   *    not                     jnz %1
   *    jzer %1                 -
   *    --------------------------------------
   *    not                     jzer %1
   *    jnz %1                  -
   */
  {
    #ifdef SCPACK
      "not!jzer %1!",
      "jnz %1!",
    #else
      "not!\355",
      "jnz\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "not!jnz %1!",
      "jzer %1!",
    #else
      "not!jnz\214",
      "\355",
    #endif
    2-1, 1-1
  },

  /* Incrementing and decrementing global and local variables, and reference
   * arguments may have redundant PUSH/POP instructions, for example when the
   * primary register is altered after restoring it, or at the end of an
   * expression.
   *    push.pri                load.s.pri %1   ; reference argument
   *    load.s.pri %1           inc.i
   *    inc.i                   lref.s.pri %2
   *    pop.pri                 -
   *    lref.s.pri %2           -
   *    --------------------------------------
   *    push.pri                load.s.pri %1
   *    load.s.pri %1           inc.i
   *    inc.i                   ;$exp
   *    pop.pri                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    push.pri                addr.pri %1     ; local variable
   *    addr.pri %1             inc.i
   *    inc.i                   load.s.pri %2
   *    pop.pri                 -
   *    load.s.pri %2           -
   *    --------------------------------------
   *    push.pri                const.pri %1    ; global variable
   *    const.pri %1            inc.i
   *    inc.i                   load.pri %2
   *    pop.pri                 -
   *    load.pri %2             -
   * The same is true for dec.i sequences.
   */
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!inc.i!pop.pri!lref.s.pri %2!",
      "load.s.pri %1!inc.i!lref.s.pri %2!",
    #else
      "\260\321\312\305\366\354\241",
      "\321\312\305\354\241",
    #endif
    5-3, 2-2
  },
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!inc.i!pop.pri!;$exp!",
      "load.s.pri %1!inc.i!;$exp!",
    #else
      "\260\321\312\305\366\257",
      "\321\312\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!inc.i!pop.pri!;load.s.pri %2!",
      "addr.pri %1!inc.i!;load.s.pri %2!",
    #else
      "\260\325\312\305\366;\266",
      "\325\312\305;\266",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!inc.i!pop.pri!;$exp!",
      "addr.pri %1!inc.i!;$exp!",
    #else
      "\260\325\312\305\366\257",
      "\325\312\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!inc.i!pop.pri!;load.pri %2!",
      "const.pri %1!inc.i!;load.pri %2!",
    #else
      "\260\304\312\305\366;\356",
      "\304\312\305;\356",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!inc.i!pop.pri!;$exp!",
      "const.pri %1!inc.i!;$exp!",
    #else
      "\260\304\312\305\366\257",
      "\304\312\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!dec.i!pop.pri!lref.s.pri %2!",
      "load.s.pri %1!dec.i!lref.s.pri %2!",
    #else
      "\260\321\314\305\366\354\241",
      "\321\314\305\354\241",
    #endif
    5-3, 2-2
  },
  {
    #ifdef SCPACK
      "push.pri!load.s.pri %1!dec.i!pop.pri!;$exp!",
      "load.s.pri %1!dec.i!;$exp!",
    #else
      "\260\321\314\305\366\257",
      "\321\314\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!dec.i!pop.pri!;load.s.pri %2!",
      "addr.pri %1!dec.i!;load.s.pri %2!",
    #else
      "\260\325\314\305\366;\266",
      "\325\314\305;\266",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!addr.pri %1!dec.i!pop.pri!;$exp!",
      "addr.pri %1!dec.i!;$exp!",
    #else
      "\260\325\314\305\366\257",
      "\325\314\305\257",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!dec.i!pop.pri!;load.pri %2!",
      "const.pri %1!dec.i!;load.pri %2!",
    #else
      "\260\304\314\305\366;\356",
      "\304\314\305;\356",
    #endif
    5-3, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri!const.pri %1!dec.i!pop.pri!;$exp!",
      "const.pri %1!dec.i!;$exp!",
    #else
      "\260\304\314\305\366\257",
      "\304\314\305\257",
    #endif
    4-2, 1-1
  },
  /* there is a special opcode for left-shift by a constant, use it */
  {
    #ifdef SCPACK
      "const.alt %1!shl!",
      "shl.c.pri %1!",
    #else
      "\250\264\327!",
      "\341\226",
    #endif
    2-1, 1-1
  },

  /* ----------------------------------- */
  /* Supplemental and macro instructions */
  /* ----------------------------------- */

  /* separator, so optimizer can stop before generating macro opcodes */
  { separator_macro, "", 0 },

  /* Array indexing can merit from special instructions.
   * Simple indexed array lookup can be optimized quite
   * a bit.
   *    addr.pri %1             addr.alt %1
   *    push.pri                load.s.pri %2
   *    load.s.pri %2           bounds %3
   *    bounds %3               lidx.b %4
   *    shl.c.pri %4            -
   *    pop.alt                 -
   *    add                     -
   *    load.i                  -
   *
   * And to prepare for storing a value in an array
   *    addr.pri %1             addr.alt %1
   *    push.pri                load.s.pri %2
   *    load.s.pri %2           bounds %3
   *    bounds %3               idxaddr.b %4
   *    shl.c.pri %4            -
   *    pop.alt                 -
   *    add                     -
   *
   * Notes (additional cases):
   * 1. instruction addr.pri can also be const.pri (for
   *    global arrays)
   * 2. the bounds instruction can be absent
   * 3. when "%4" (the shift value) is 2 (with 32-bit cells), use the
   *    even more optimal instructions LIDX and IDDXADDR
   *
   * If the array index is more complex, one can only optimize
   * the last four instructions:
   *    shl.c.pri %1            pop.alt
   *    pop.alt                 lidx.b %1
   *    add                     -
   *    loadi                   -
   *    --------------------------------------
   *    shl.c.pri %1            pop.alt
   *    pop.alt                 idxaddr.b %1
   *    add                     -
   */
#if !defined BIT16
  /* loading from array, "cell" shifted */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!bounds %3!lidx!",
    #else
      "\325\344\357\341\203\215\360\220\305",
      "\275\352\357l\340!",
    #endif
    8-4, 4-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!bounds %3!lidx!",
    #else
      "\304\344\357\341\203\215\360\220\305",
      "\250\352\357l\340!",
    #endif
    8-4, 4-3
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!lidx!",
    #else
      "\325\344\341\203\215\360\220\305",
      "\275\352l\340!",
    #endif
    7-3, 3-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!lidx!",
    #else
      "\304\344\341\203\215\360\220\305",
      "\250\352l\340!",
    #endif
    7-3, 3-2
  },
#endif
  /* loading from array, not "cell" shifted */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!bounds %3!lidx.b %4!",
    #else
      "\325\344\357\341\230\310\360\220\305",
      "\275\352\357l\340.b\331",
    #endif
    8-4, 4-4
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!bounds %3!lidx.b %4!",
    #else
      "\304\344\357\341\230\310\360\220\305",
      "\250\352\357l\340.b\331",
    #endif
    8-4, 4-4
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!load.i!",
      "addr.alt %1!load.s.pri %2!lidx.b %3!",
    #else
      "\325\344\341\2303!\360\220\305",
      "\275\352l\340.b\270",
    #endif
    7-3, 3-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!load.i!",
      "const.alt %1!load.s.pri %2!lidx.b %3!",
    #else
      "\304\344\341\2303!\360\220\305",
      "\250\352l\340.b\270",
    #endif
    7-3, 3-3
  },
#if !defined BIT16
  /* array index calculation for storing a value, "cell" aligned */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!bounds %3!idxaddr!",
    #else
      "\325\344\357\341\203\215\360",
      "\275\352\357\340\243\227",
    #endif
    7-4, 4-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri 2!pop.alt!add!",
      "const.alt %1!load.s.pri %2!bounds %3!idxaddr!",
    #else
      "\304\344\357\341\203\215\360",
      "\250\352\357\340\243\227",
    #endif
    7-4, 4-3
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!idxaddr!",
    #else
      "\325\344\341\203\215\360",
      "\275\352\340\243\227",
    #endif
    6-3, 3-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri 2!pop.alt!add!",
      "const.alt %1!load.s.pri %2!idxaddr!",
    #else
      "\304\344\341\203\215\360",
      "\250\352\340\243\227",
    #endif
    6-3, 3-2
  },
#endif
  /* array index calculation for storing a value, not "cell" packed */
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!bounds %3!idxaddr.b %4!",
    #else
      "\325\344\357\341\230\310\360",
      "\275\352\357\340\275.b\331",
    #endif
    7-4, 4-4
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!bounds %3!shl.c.pri %4!pop.alt!add!",
      "const.alt %1!load.s.pri %2!bounds %3!idxaddr.b %4!",
    #else
      "\304\344\357\341\230\310\360",
      "\250\352\357\340\275.b\331",
    #endif
    7-4, 4-4
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!",
      "addr.alt %1!load.s.pri %2!idxaddr.b %3!",
    #else
      "\325\344\341\2303!\360",
      "\275\352\340\275.b\270",
    #endif
    6-3, 3-3
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!load.s.pri %2!shl.c.pri %3!pop.alt!add!",
      "const.alt %1!load.s.pri %2!idxaddr.b %3!",
    #else
      "\304\344\341\2303!\360",
      "\250\352\340\275.b\270",
    #endif
    6-3, 3-3
  },
#if !defined BIT16
  /* the shorter array indexing sequences, see above for comments */
  {
    #ifdef SCPACK
      "shl.c.pri 2!pop.alt!add!loadi!",
      "pop.alt!lidx!",
    #else
      "\341\203\215\360\220\225",
      "\263l\340!",
    #endif
    4-2, 1-0
  },
  {
    #ifdef SCPACK
      "shl.c.pri 2!pop.alt!add!",
      "pop.alt!idxaddr!",
    #else
      "\341\203\215\360",
      "\263\340\243\227",
    #endif
    3-2, 1-0
  },
#endif
  {
    #ifdef SCPACK
      "shl.c.pri %1!pop.alt!add!loadi!",
      "pop.alt!lidx.b %1!",
    #else
      "\341\226\360\220\225",
      "\263l\340.b\214",
    #endif
    4-2, 1-1
  },
  {
    #ifdef SCPACK
      "shl.c.pri %1!pop.alt!add!",
      "pop.alt!idxaddr.b %1!",
    #else
      "\341\226\360",
      "\263\340\275.b\214",
    #endif
    3-2, 1-1
  },
  /* Declaration of simple variables often follows the sequence:
   *    ;$lcl <name> <stk>      ;$lcl <name> <stk>
   *    stack -4                push.c <constval>
   *    const.pri <constval>    ;$exp
   *    stor.s <stk>            -
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!const.pri %3!stor.s %2!;$exp!",
      ";$lcl %1 %2!push.c %3!;$exp!",
    #else
      "\216lcl\342\234ack -\310\250\2303!\370\213\245\257",
      "\216lcl\342\212\236\270\257",
    #endif
    3-1, 3-1
  },
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!zero.pri!stor.s %2!;$exp!",
      ";$lcl %1 %2!push.c #0!;$exp!",
    #else
      "\216lcl\342\234ack -\310\350\240\370\213\245\257",
      "\216lcl\342\212\236\311\242\257",
    #endif
    3-1, 2-1
  },
#if 0
  /* When variables are declared and assigned a variable, the sequence is:
   *    ;$lcl <name> <stk>      ;$lcl <name> <stk>
   *    stack -4                stack -4
   *    load.pri <addr>         load.pri <addr>
   *    stor.s <stk>            stor.i
   *    ;$exp                   ;$exp
   */
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!load.pri %3!stor.s %2!;$exp!",
      ";$lcl %1 %2!stack #-4!load.pri %3!stor.i!;$exp!",
    #else
      "\216lcl\342\234ack -\310\220\2303!\370\213\245\257",
      "\216lcl\342\234ack\311-\310\220\2303!\370\305\257",
    #endif
    3-3, 3-2
  },
  {
    #ifdef SCPACK
      ";$lcl %1 %2!stack -4!load.s.pri %3!stor.s %2!;$exp!",
      ";$lcl %1 %2!stack #-4!load.s.pri %3!stor.i!;$exp!",
    #else
      "\216lcl\342\234ack -\310\235\2303!\370\213\245\257",
      "\216lcl\342\234ack\311-\310\235\2303!\370\305\257",
    #endif
    3-3, 3-2
  },
#endif
  /* simple arithmetic sequences, involving subtraction */
  {
    #ifdef SCPACK
      "xchg!load.s.pri %1!sub!",
      "load.s.alt %1!sub.inv!",
    #else
      "\274\321sub!",
      "\235\264sub.\307v!",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!load.pri %1!sub!",
      "load.alt %1!sub.inv!",
    #else
      "\274\332sub!",
      "\220\264sub.\307v!",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!const.pri %1!sub!",
      "const.alt %1!sub.inv!",
    #else
      "\274\304sub!",
      "\250\264sub.\307v!",
    #endif
    3-2, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!lref.s.pri %1!sub!",
      "lref.s.alt %1!sub.inv!",
    #else
      "\274\354\226sub!",
      "\354\264sub.\307v!",
    #endif
    3-2, 1-1
  },
  /* optimizing the calling of native functions (which always have a parameter
   * count pushed before, and the stack pointer restored afterwards
   */
  {
    #ifdef SCPACK
      "push.c %1!sysreq %2!stack %3!",        //note: %3 == %1 + 4
      "sysreq.n %2 %1!",
    #else
      "\212\362sysr\302\245\234ack\270",
      "sysr\302.n\333\214",
    #endif
    3-1, 3-2
  },
  /* User-defined operators first load the operands into registers and
   * then have them pushed onto the stack. This can give rise to sequences
   * like:
   *    const.pri %1            push.c %1
   *    const.alt %2            push.c %2
   *    push.pri                -
   *    push.alt                -
   * A similar sequence occurs with the two PUSH.pri/alt instructions inverted.
   * The first, second, or both CONST.pri/alt instructions can also be
   * LOAD.pri/alt.
   * This gives 2 x 4 cases.
   */
  {
    #ifdef SCPACK
      "const.pri %1!const.alt %2!push.pri!push.alt!",
      "push.c %1!push.c %2!",
    #else
      "\304\250\343\260\212\244",
      "\212\362\212\236\245",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!const.alt %2!push.alt!push.pri!",
      "push.c %2!push.c %1!",
    #else
      "\304\250\343\212\244\260",
      "\212\236\245\212\362",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!push.pri!push.alt!",
      "push.c %1!push %2!",
    #else
      "\304\220\343\260\212\244",
      "\212\362\212\245",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!push.alt!push.pri!",
      "push %2!push.c %1!",
    #else
      "\304\220\343\212\244\260",
      "\212\245\212\362",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!push.pri!push.alt!",
      "push %1!push.c %2!",
    #else
      "\332\250\343\260\212\244",
      "\212\214\212\236\245",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!const.alt %2!push.alt!push.pri!",
      "push.c %2!push %1!",
    #else
      "\332\250\343\212\244\260",
      "\212\236\245\212\214",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!push.pri!push.alt!",
      "push %1!push %2!",
    #else
      "\332\220\343\260\212\244",
      "\212\214\212\245",
    #endif
    4-2, 2-2
  },
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!push.alt!push.pri!",
      "push %2!push %1!",
    #else
      "\332\220\343\212\244\260",
      "\212\245\212\214",
    #endif
    4-2, 2-2
  },
  /* Function calls (parameters are passed on the stack)
   *    load.s.pri %1           push.s %1
   *    push.pri                -
   *    --------------------------------------
   *    load.pri %1             push %1
   *    push.pri                -
   *    --------------------------------------
   *    const.pri %1            push.c %1
   *    push.pri                -
   *    --------------------------------------
   *    zero.pri                push.c 0
   *    push.pri                -
   *    --------------------------------------
   *    addr.pri %1             push.adr %1
   *    push.pri                -
   *
   * However, PRI must not be needed after this instruction
   * if this shortcut is used. Check for the ;$par comment.
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!push.pri!;$par!",
      "push.s %1!;$par!",
    #else
      "\321\260\233",
      "\212\361\233",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "load.pri %1!push.pri!;$par!",
      "push %1!;$par!",
    #else
      "\332\260\233",
      "\212\214\233",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!push.pri!;$par!",
      "push.c %1!;$par!",
    #else
      "\304\260\233",
      "\212\362\233",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.pri!push.pri!;$par!",
      "push.c #0!;$par!",
    #else
      "\350\240\260\233",
      "\212\236\311\242\233",
    #endif
    2-1, 0-1
  },
  {
    #ifdef SCPACK
      "addr.pri %1!push.pri!;$par!",
      "push.adr %1!;$par!",
    #else
      "\325\260\233",
      "\212\300\214\233",
    #endif
    2-1, 1-1
  },
  /* Native function calls with parameters that must be relocated.
   * Note that global variables cannot hold an address and therefore
   * no "pushr" instruction exists (a local variable holds an address
   * if that variable is a function argument that refers to an array).
   *
   *    load.s.pri %1           pushr.s %1
   *    pushr.pri               -
   *    --------------------------------------
   *    const.pri %1            pushr.c %1
   *    pushr.pri               -
   *    --------------------------------------
   *    zero.pri                pushr.c 0
   *    pushr.pri               -
   *    --------------------------------------
   *    addr.pri %1             pushr.adr %1
   *    pushr.pri               -
   *
   * Again, PRI must not be needed after this instruction
   * if this shortcut is used. Check for the ;$par comment.
   */
  {
    #ifdef SCPACK
      "load.s.pri %1!pushr.pri!;$par!",
      "pushr.s %1!;$par!",
    #else
      "\321\253\240\233",
      "\253\361\233",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!pushr.pri!;$par!",
      "pushr.c %1!;$par!",
    #else
      "\304\253\240\233",
      "\253\362\233",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.pri!pushr.pri!;$par!",
      "pushr.c #0!;$par!",
    #else
      "\350\240\253\240\233",
      "\253\236\311\242\233",
    #endif
    2-1, 0-1
  },
  {
    #ifdef SCPACK
      "addr.pri %1!pushr.pri!;$par!",
      "pushr.adr %1!;$par!",
    #else
      "\325\253\240\233",
      "\253\300\214\233",
    #endif
    2-1, 1-1
  },
  /* Simple arithmetic operations on constants. Subtraction is handled in
   * a separate section, because it is not commutative.
   *    const.alt %1            add.c %1
   *    add                     -
   *    --------------------------------------
   *    const.alt %1            smul.c %1
   *    smul                    -
   *    --------------------------------------
   *    const.alt %1            eq.c.pri %1
   *    eq                      -
   */
  {
    #ifdef SCPACK
      "const.alt %1!add!",
      "add.c %1!",
    #else
      "\250\264\324",
      "\243\362",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.alt %1!smul!",
      "smul.c %1!",
    #else
      "\250\264smul!",
      "smul\362",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.alt %1!eq!",
      "eq.c.pri %1!",
    #else
      "\250\264\326",
      "\302\236\226",
    #endif
    2-1, 1-1
  },
  /* Subtraction of a constant. Note that the subtraction is converted to
   * the addition of the inverse value.
   *    const.pri %1            load.s.pri %2
   *    load.s.alt %2           add.c -%1
   *    sub                     -
   *    --------------------------------------
   *    const.pri %1            load.pri %2
   *    load.alt %2             add.c -%1
   *    sub                     -
   */
  {
    #ifdef SCPACK
      "const.pri %1!load.s.alt %2!sub!",
      "load.s.pri %2!add.c -%1!",
    #else
      "\304\235\343sub!",
      "\266\243\236 -\205",
    #endif
    3-2, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!load.alt %2!sub!",
      "load.pri %2!add.c -%1!",
    #else
      "\304\220\343sub!",
      "\356\243\236 -\205",
    #endif
    3-2, 2-2
  },
  /* With arrays indexed with constants that come from enumerations, it happens
   * multiple add.c opcodes follow in sequence.
   *    add.c %1                add.c %1+%2
   *    add.c %2                -
   */
  {
    #ifdef SCPACK
      "add.c %1!add.c %2!",
      "add.c %1+%2!",
    #else
      "\243\362\243\236\245",
      "\243\236\265+%\215",
    #endif
    2-1, 2-1
  },
  /* Compare and jump in chained and non-chained relation expressions.
   * The exchange operation may be removed on relation operators
   * by selecting the inverse relational operator
   *    xchg                    jsgeq  %1   also for sless, sgeq and sleq
   *    sgrtr                   ;$exp       (occurs for non-chained comparisons)
   *    jzer %1                 -
   *    ;$exp                   -
   *    --------------------------------------
   *    xchg                    sless       also for sless, sgeq and sleq
   *    sgrtr                   ;$exp       (occurs for non-chained comparisons)
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      "xchg!sgrtr!jzer %1!;$exp!",
      "jsgeq %1!;$exp!",
    #else
      "\274\336rt\227\334\316",
      "j\336\302\316",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!sless!jzer %1!;$exp!",
      "jsleq %1!;$exp!",
    #else
      "\274\337ess!\334\316",
      "j\337\302\316",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!sgeq!jzer %1!;$exp!",
      "jsgrtr %1!;$exp!",
    #else
      "\274\336\326\334\316",
      "j\336rtr\316",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "xchg!sleq!jzer %1!;$exp!",
      "jsless %1!;$exp!",
    #else
      "\274\337\326\334\316",
      "j\337ess\316",
    #endif
    3-1, 1-1
  },
  /* Standard compare and jump
   *    eq                      jneq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    eq                      jeq %1
   *    jnz %1                  -
   *    --------------------------------------
   *    neq                     jeq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    neq                     jneq %1
   *    jnz %1                  -
   * An similarly for other relations
   *    sless                   jsgeq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sless                   jsless %1
   *    jnz %1                  -
   *    --------------------------------------
   *    sleq                    jsgrtr %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sleq                    jsleq %1
   *    jnz %1                  -
   *    --------------------------------------
   *    sgrtr                   jsleq %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sgrtr                   jsgrtr %1
   *    jnz %1                  -
   *    --------------------------------------
   *    sgeq                    jsless %1
   *    jzer %1                 -
   *    --------------------------------------
   *    sgeq                    jsgeq %1
   *    jnz %1                  -
   * We can relax the optimizations for the unsigned comparisons,
   * because the Pawn compiler currently only generates signed
   * comparisons.
   */
  {
    #ifdef SCPACK
      "eq!jzer %1!",
      "jneq %1!",
    #else
      "\326\355",
      "jn\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "eq!jnz %1!",
      "jeq %1!",
    #else
      "\326jnz\214",
      "j\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "neq!jzer %1!",
      "jeq %1!",
    #else
      "n\326\355",
      "j\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "neq!jnz %1!",
      "jneq %1!",
    #else
      "n\326jnz\214",
      "jn\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sless!jzer %1!",
      "jsgeq %1!",
    #else
      "\337ess!\355",
      "j\336\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sless!jnz %1!",
      "jsless %1!",
    #else
      "\337ess!jnz\214",
      "j\337ess\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sleq!jzer %1!",
      "jsgrtr %1!",
    #else
      "\337\326\355",
      "j\336rtr\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sleq!jnz %1!",
      "jsleq %1!",
    #else
      "\337\326jnz\214",
      "j\337\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgrtr!jzer %1!",
      "jsleq %1!",
    #else
      "\336rt\227\355",
      "j\337\302\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgrtr!jnz %1!",
      "jsgrtr %1!",
    #else
      "\336rt\227jnz\214",
      "j\336rtr\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgeq!jzer %1!",
      "jsless %1!",
    #else
      "\336\326\355",
      "j\337ess\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "sgeq!jnz %1!",
      "jsgeq %1!",
    #else
      "\336\326jnz\214",
      "j\336\302\214",
    #endif
    2-1, 1-1
  },
  /* select more appropriate INC and DEC opcodes
   *    addr.pri %1             inc.s %1
   *    inc.i                   -
   *    --------------------------------------
   *    const.pri %1            inc %1
   *    inc.i                   -
   * and the same for DEC
   */
  {
    #ifdef SCPACK
      "addr.pri %1!inc.i!",
      "inc.s %1!",
    #else
      "\325\312\305",
      "\312\361",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!inc.i!",
      "inc %1!",
    #else
      "\304\312\305",
      "\312\214",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "addr.pri %1!dec.i!",
      "dec.s %1!",
    #else
      "\325\314\305",
      "\314\361",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri %1!dec.i!",
      "dec %1!",
    #else
      "\304\314\305",
      "\314\214",
    #endif
    2-1, 1-1
  },
  /* remove redundant PUSH/POP around an increment, if these
   * are (still) present
   *    push.pri                inc.s %1
   *    inc.s %1                -
   *    pop.pri                 -
   *    --------------------------------------
   *    push.pri                inc %1
   *    inc %1                  -
   *    pop.pri                 -
   * and the same for DEC
   */
  {
    #ifdef SCPACK
      "push.pri %1!inc.s %1!pop.pri!",
      "inc.s %1!",
    #else
      "\212\226\312\361\366",
      "\312\361",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri %1!inc %1!pop.pri!",
      "inc %1!",
    #else
      "\212\226\312\214\366",
      "\312\214",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri %1!dec.s %1!pop.pri!",
      "dec.s %1!",
    #else
      "\212\226\314\361\366",
      "\314\361",
    #endif
    3-1, 1-1
  },
  {
    #ifdef SCPACK
      "push.pri %1!dec %1!pop.pri!",
      "dec %1!",
    #else
      "\212\226\314\214\366",
      "\314\214",
    #endif
    3-1, 1-1
  },
  /* Incrementing and decrementing leaves a value in
   * in PRI which may not be used (for example, as the
   * third expression in a "for" loop).
   *    inc %1                  inc %1  ; ++n
   *    load.pri %1             ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    load.pri %1             inc %1  ; n++, e.g. "for (n=0; n<10; n++)"
   *    inc %1                  ;$exp
   *    ;$exp                   -
   * Plus the varieties for stack relative increments
   * and decrements.
   */
  {
    #ifdef SCPACK
      "inc %1!load.pri %1!;$exp!",
      "inc %1!;$exp!",
    #else
      "\312\214\332\257",
      "\312\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.pri %1!inc %1!;$exp!",
      "inc %1!;$exp!",
    #else
      "\332\312\316",
      "\312\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "inc.s %1!load.s.pri %1!;$exp!",
      "inc.s %1!;$exp!",
    #else
      "\312\361\321\257",
      "\312\213\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!inc.s %1!;$exp!",
      "inc.s %1!;$exp!",
    #else
      "\321\312\213\316",
      "\312\213\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "dec %1!load.pri %1!;$exp!",
      "dec %1!;$exp!",
    #else
      "\314\214\332\257",
      "\314\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.pri %1!dec %1!;$exp!",
      "dec %1!;$exp!",
    #else
      "\332\314\316",
      "\314\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "dec.s %1!load.s.pri %1!;$exp!",
      "dec.s %1!;$exp!",
    #else
      "\314\361\321\257",
      "\314\213\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!dec.s %1!;$exp!",
      "dec.s %1!;$exp!",
    #else
      "\321\314\213\316",
      "\314\213\316",
    #endif
    2-1, 2-1
  },
  /* Loading the constant zero has a special opcode.
   * When storing zero in memory, the value of PRI must not be later on.
   *    const.pri 0             zero %1
   *    stor %1                 ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri 0             zero.s %1
   *    stor.s %1               ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    zero.pri                zero %1
   *    stor %1                 ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    zero.pri                zero.s %1
   *    stor.s %1               ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri 0             zero.pri
   *    --------------------------------------
   *    const.alt 0             zero.alt
   * The last two alternatives save more memory than they save
   * time, but anyway...
   */
  {
    #ifdef SCPACK
      "const.pri 0!stor %1!;$exp!",
      "zero %1!;$exp!",
    #else
      "\250\203\242\370\316",
      "\350\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "const.pri 0!stor.s %1!;$exp!",
      "zero.s %1!;$exp!",
    #else
      "\250\203\242\370\213\316",
      "\350\213\316",
    #endif
    2-1, 2-1
  },
  {
    #ifdef SCPACK
      "zero.pri!stor %1!;$exp!",
      "zero %1!;$exp!",
    #else
      "\350\240\370\316",
      "\350\316",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "zero.pri!stor.s %1!;$exp!",
      "zero.s %1!;$exp!",
    #else
      "\350\240\370\213\316",
      "\350\213\316",
    #endif
    2-1, 1-1
  },
  {
    #ifdef SCPACK
      "const.pri +0!",
      "zero.pri!",
    #else
      "\250\203+\242",
      "\350\240",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "const.alt +0!",
      "zero.alt!",
    #else
      "\250\223 +\242",
      "\350\244",
    #endif
    1-1, 1-0
  },
  /* ----- */
  /* Functions with many parameters with the same "type" have sequences like:
   *    push.c %1               pushm.c 3 %1 %2 %3
   *    ;$par                   ;$par
   *    push.c %2               -
   *    ;$par                   -
   *    push.c %3               -
   *    ;$par                   -
   *    etc.                    etc.
   *
   * Similar sequences occur with PUSH, PUSH.s and PUSHADDR, plus
   * PUSHR.c, PUSHR.s and PUSHR.adr
   */
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!push.c %4!;$par!push.c %5!;$par!",
      "pushm.c #5 %1 %2 %3 %4 %5!",
    #else
      "\212\362\303\236\245\303\236\270\303\236\331\303\236\206\322\233",
      "\330\236\3115\373\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!push.c %4!;$par!",
      "pushm.c #4 %1 %2 %3 %4!",
    #else
      "\212\362\303\236\245\303\236\270\303\236\331\233",
      "\330\236\3114\373\331",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!push.c %3!;$par!",
      "pushm.c #3 %1 %2 %3!",
    #else
      "\212\362\303\236\245\303\236\270\233",
      "\330\236\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push.c %1!;$par!push.c %2!;$par!",
      "pushm.c #2 %1 %2!",
    #else
      "\212\362\303\236\245\233",
      "\330\236\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!push %4!;$par!push %5!;$par!",
      "pushm #5 %1 %2 %3 %4 %5!",
    #else
      "\212\214\303\245\303\270\303\331\303\206\322\233",
      "\330\3115\373\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!push %4!;$par!",
      "pushm #4 %1 %2 %3 %4!",
    #else
      "\212\214\303\245\303\270\303\331\233",
      "\330\3114\373\331",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!push %3!;$par!",
      "pushm #3 %1 %2 %3!",
    #else
      "\212\214\303\245\303\270\233",
      "\330\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push %1!;$par!push %2!;$par!",
      "pushm #2 %1 %2!",
    #else
      "\212\214\303\245\233",
      "\330\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!push.s %4!;$par!push.s %5!;$par!",
      "pushm.s #5 %1 %2 %3 %4 %5!",
    #else
      "\212\361\303\213\245\303\213\270\303\213\331\303\213\206\322\233",
      "\330\213\3115\373\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!push.s %4!;$par!",
      "pushm.s #4 %1 %2 %3 %4!",
    #else
      "\212\361\303\213\245\303\213\270\303\213\331\233",
      "\330\213\3114\373\331",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!push.s %3!;$par!",
      "pushm.s #3 %1 %2 %3!",
    #else
      "\212\361\303\213\245\303\213\270\233",
      "\330\213\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push.s %1!;$par!push.s %2!;$par!",
      "pushm.s #2 %1 %2!",
    #else
      "\212\361\303\213\245\233",
      "\330\213\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!push.adr %4!;$par!push.adr %5!;$par!",
      "pushm.adr #5 %1 %2 %3 %4 %5!",
    #else
      "\212\300\214\303\300\245\303\300\270\303\300\331\303\300\206\322\233",
      "\330\300\3115\373\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!push.adr %4!;$par!",
      "pushm.adr #4 %1 %2 %3 %4!",
    #else
      "\212\300\214\303\300\245\303\300\270\303\300\331\233",
      "\330\300\3114\373\331",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!push.adr %3!;$par!",
      "pushm.adr #3 %1 %2 %3!",
    #else
      "\212\300\214\303\300\245\303\300\270\233",
      "\330\300\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "push.adr %1!;$par!push.adr %2!;$par!",
      "pushm.adr #2 %1 %2!",
    #else
      "\212\300\214\303\300\245\233",
      "\330\300\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!pushr.c %3!;$par!pushr.c %4!;$par!pushr.c %5!;$par!",
      "pushrm.c #5 %1 %2 %3 %4 %5!",
    #else
      "\253\362\315\236\245\315\236\270\315\236\331\315\236\206\322\233",
      "\363\236\3115\373\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!pushr.c %3!;$par!pushr.c %4!;$par!",
      "pushrm.c #4 %1 %2 %3 %4!",
    #else
      "\253\362\315\236\245\315\236\270\315\236\331\233",
      "\363\236\3114\373\331",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!pushr.c %3!;$par!",
      "pushrm.c #3 %1 %2 %3!",
    #else
      "\253\362\315\236\245\315\236\270\233",
      "\363\236\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "pushr.c %1!;$par!pushr.c %2!;$par!",
      "pushrm.c #2 %1 %2!",
    #else
      "\253\362\315\236\245\233",
      "\363\236\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!pushr.s %3!;$par!pushr.s %4!;$par!pushr.s %5!;$par!",
      "pushrm.s #5 %1 %2 %3 %4 %5!",
    #else
      "\253\361\315\213\245\315\213\270\315\213\331\315\213\206\322\233",
      "\363\213\3115\373\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!pushr.s %3!;$par!pushr.s %4!;$par!",
      "pushrm.s #4 %1 %2 %3 %4!",
    #else
      "\253\361\315\213\245\315\213\270\315\213\331\233",
      "\363\213\3114\373\331",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!pushr.s %3!;$par!",
      "pushrm.s #3 %1 %2 %3!",
    #else
      "\253\361\315\213\245\315\213\270\233",
      "\363\213\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "pushr.s %1!;$par!pushr.s %2!;$par!",
      "pushrm.s #2 %1 %2!",
    #else
      "\253\361\315\213\245\233",
      "\363\213\3112\342",
    #endif
    2-1, 2-3
  },
  /* ----- */
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!pushr.adr %3!;$par!pushr.adr %4!;$par!pushr.adr %5!;$par!",
      "pushrm.adr #5 %1 %2 %3 %4 %5!",
    #else
      "\253\300\214\315\300\245\315\300\270\315\300\331\315\300\206\322\233",
      "\363\300\3115\373\2064\206\322",
    #endif
    5-1, 5-6
  },
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!pushr.adr %3!;$par!pushr.adr %4!;$par!",
      "pushrm.adr #4 %1 %2 %3 %4!",
    #else
      "\253\300\214\315\300\245\315\300\270\315\300\331\233",
      "\363\300\3114\373\331",
    #endif
    4-1, 4-5
  },
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!pushr.adr %3!;$par!",
      "pushrm.adr #3 %1 %2 %3!",
    #else
      "\253\300\214\315\300\245\315\300\270\233",
      "\363\300\3113\353\270",
    #endif
    3-1, 3-4
  },
  {
    #ifdef SCPACK
      "pushr.adr %1!;$par!pushr.adr %2!;$par!",
      "pushrm.adr #2 %1 %2!",
    #else
      "\253\300\214\315\300\245\233",
      "\363\300\3112\342",
    #endif
    2-1, 2-3
  },
  /* Loading two registers at a time
   *    load.pri %1             load2 %1 %2
   *    load.alt %2             -
   *    --------------------------------------
   *    load.alt %2             load2 %1 %2
   *    load.pri %1             -
   *    --------------------------------------
   *    load.s.pri %1           load2.s %1 %2
   *    load.s.alt %2           -
   *    --------------------------------------
   *    load.s.alt %2           load2.s %1 %2
   *    load.s.pri %1           -
   */
  {
    #ifdef SCPACK
      "load.pri %1!load.alt %2!",
      "load2 %1 %2!",
    #else
      "\332\220\343",
      "\2202\342",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "load.alt %2!load.pri %1!",
      "load2 %1 %2!",
    #else
      "\220\343\332",
      "\2202\342",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.pri %1!load.s.alt %2!",
      "load2.s %1 %2!",
    #else
      "\321\235\343",
      "\2202\213\342",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "load.s.alt %2!load.s.pri %1!",
      "load2.s %1 %2!",
    #else
      "\235\343\321",
      "\2202\213\342",
    #endif
    2-1, 2-2
  },
  /* Loading two registers and then pushing them occurs with user operators
   *    load2 %1 %2            pushm 2 %1 %2
   *    push.pri                -
   *    push.alt                -
   *    --------------------------------------
   *    load2.s %1 %2          pushm.s 2 %1 %2
   *    push.pri                -
   *    push.alt                -
   */
  {
    #ifdef SCPACK
      "load2 %1 %2!push.pri!push.alt!",
      "pushm #2 %1 %2!",
    #else
      "\2202\342\260\212\244",
      "\330\3112\342",
    #endif
    3-1, 2-3
  },
  {
    #ifdef SCPACK
      "load2.s %1 %2!push.pri!push.alt!",
      "pushm.s #2 %1 %2!",
    #else
      "\2202\213\342\260\212\244",
      "\330\213\3112\342",
    #endif
    3-1, 2-3
  },
  /* Load a constant in a variable
   *    const.pri %1            const %2 %1
   *    stor %2                 ;$exp
   *    ;$exp                   -
   *    --------------------------------------
   *    const.pri %1            const.s %2 %1
   *    stor.s %2               ;$exp
   *    ;$exp                   -
   */
  {
    #ifdef SCPACK
      "const.pri %1!stor %2!;$exp!",
      "const %2 %1!;$exp!",
    #else
      "\304\370\245\257",
      "\250\333\316",
    #endif
    2-1, 2-2
  },
  {
    #ifdef SCPACK
      "const.pri %1!stor.s %2!;$exp!",
      "const.s %2 %1!;$exp!",
    #else
      "\304\370\213\245\257",
      "\250\213\333\316",
    #endif
    2-1, 2-2
  },


  /* ------------------ */
  /* Packed opcodes     */
  /* ------------------ */

  /* separator, so optimizer can stop before generating macro opcodes */
  { separator_full, "", 0 },

  /* If %0 is in the range cell_min .. cell_max, do conversions like:
   *    add.c %0                add.p.c %0
   *
   * Rules in this section may only use %0 (a special symbol which matches
   * a numeric cell in a restricted range and replaces it with a shorter
   * representation of the same value).
   */

  {
    #ifdef SCPACK
      "load.pri %0!",
      "load.p.pri %0!",
    #else
      "\220\364",
      "\220\224\364",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "load.alt %0!",
      "load.p.alt %0!",
    #else
      "\220\223\261",
      "\220\224\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "load.s.pri %0!",
      "load.p.s.pri %0!",
    #else
      "\235\364",
      "\220\224\213\364",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "load.s.alt %0!",
      "load.p.s.alt %0!",
    #else
      "\235\223\261",
      "\220\224\213\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lref.s.pri %0!",
      "lref.p.s.pri %0!",
    #else
      "\354\364",
      "\323\224\213\364",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lref.s.alt %0!",
      "lref.p.s.alt %0!",
    #else
      "\354\223\261",
      "\323\224\213\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lodb.i %0!",
      "lodb.p.i %0!",
    #else
      "\217db.\200%\242",
      "\217db\224.\200%\242",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "const.pri %0!",
      "const.p.pri %0!",
    #else
      "\250\364",
      "\250\224\364",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "const.alt %0!",
      "const.p.alt %0!",
    #else
      "\250\223\261",
      "\250\224\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "addr.pri %0!",
      "addr.p.pri %0!",
    #else
      "\275\364",
      "\275\224\364",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "addr.alt %0!",
      "addr.p.alt %0!",
    #else
      "\275\223\261",
      "\275\224\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "stor %0!",
      "stor.p %0!",
    #else
      "\370\261",
      "\370\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "stor.s %0!",
      "stor.p.s %0!",
    #else
      "\370\376",
      "\370\224\376",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "sref.s %0!",
      "sref.p.s %0!",
    #else
      "s\320\376",
      "s\320\224\376",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "strb.i %0!",
      "strb.p.i %0!",
    #else
      "\234rb.\200%\242",
      "\234rb\224.\200%\242",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "lidx.b %0!",
      "lidx.p.b %0!",
    #else
      "l\340.b\261",
      "l\340\224.b\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "idxaddr.b %0!",
      "idxaddr.p.b %0!",
    #else
      "\340\275.b\261",
      "\340\275\224.b\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "align.pri %0!",
      "align.p.pri %0!",
    #else
      "\221ign\364",
      "\221ign\224\364",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push.c %0!",
      "push.p.c %0!",
    #else
      "\212\236\261",
      "\212\224\236\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push %0!",
      "push.p %0!",
    #else
      "\212\261",
      "\212\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push.s %0!",
      "push.p.s %0!",
    #else
      "\212\376",
      "\212\224\376",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "push.adr %0!",
      "push.p.adr %0!",
    #else
      "\212\300\261",
      "\212\224\300\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushr.c %0!",
      "pushr.p.c %0!",
    #else
      "\253\236\261",
      "\253\224\236\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushr.s %0!",
      "pushr.p.s %0!",
    #else
      "\253\376",
      "\253\224\376",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushr.adr %0!",
      "pushr.p.adr %0!",
    #else
      "\253\300\261",
      "\253\224\300\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm.c %0 %1~%2~%3~%4~%5!",
      "pushm.p.c %0 %1~%2~%3~%4~%5!",
    #else
      "\330\236\375\265\372\374\2674\267\322",
      "\330\224\236\375\265\372\374\2674\267\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm %0 %1~%2~%3~%4~%5!",
      "pushm.p %0 %1~%2~%3~%4~%5!",
    #else
      "\330\375\265\372\374\2674\267\322",
      "\330\224\375\265\372\374\2674\267\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm.s %0 %1~%2~%3~%4~%5!",
      "pushm.p.s %0 %1~%2~%3~%4~%5!",
    #else
      "\330\213\375\265\372\374\2674\267\322",
      "\330\224\213\375\265\372\374\2674\267\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushm.adr %0 %1~%2~%3~%4~%5!",
      "pushm.p.adr %0 %1~%2~%3~%4~%5!",
    #else
      "\330\300\375\265\372\374\2674\267\322",
      "\330\224\300\375\265\372\374\2674\267\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushrm.c %0 %1~%2~%3~%4~%5!",
      "pushrm.p.c %0 %1~%2~%3~%4~%5!",
    #else
      "\363\236\375\265\372\374\2674\267\322",
      "\363\224\236\375\265\372\374\2674\267\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushrm.s %0 %1~%2~%3~%4~%5!",
      "pushrm.p.s %0 %1~%2~%3~%4~%5!",
    #else
      "\363\213\375\265\372\374\2674\267\322",
      "\363\224\213\375\265\372\374\2674\267\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "pushrm.adr %0 %1~%2~%3~%4~%5!",
      "pushrm.p.adr %0 %1~%2~%3~%4~%5!",
    #else
      "\363\300\375\265\372\374\2674\267\322",
      "\363\224\300\375\265\372\374\2674\267\322",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "stack %0!",
      "stack.p %0!",
    #else
      "\234ack\261",
      "\234ack\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "heap %0!",
      "heap.p %0!",
    #else
      "heap\261",
      "heap\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "shl.c.pri %0!",
      "shl.p.c.pri %0!",
    #else
      "\341\364",
      "\327\224\236\364",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "shl.c.alt %0!",
      "shl.p.c.alt %0!",
    #else
      "\341\223\261",
      "\327\224\236\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "add.c %0!",
      "add.p.c %0!",
    #else
      "\243\236\261",
      "\243\224\236\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "smul.c %0!",
      "smul.p.c %0!",
    #else
      "smul\236\261",
      "smul\224\236\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "zero %0!",
      "zero.p %0!",
    #else
      "\350\261",
      "\350\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "zero.s %0!",
      "zero.p.s %0!",
    #else
      "\350\376",
      "\350\224\376",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "eq.c.pri %0!",
      "eq.p.c.pri %0!",
    #else
      "\302\236\364",
      "\302\224\236\364",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "eq.c.alt %0!",
      "eq.p.c.alt %0!",
    #else
      "\302\236\223\261",
      "\302\224\236\223\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "inc %0!",
      "inc.p %0!",
    #else
      "\312\261",
      "\312\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "inc.s %0!",
      "inc.p.s %0!",
    #else
      "\312\376",
      "\312\224\376",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "dec %0!",
      "dec.p %0!",
    #else
      "\314\261",
      "\314\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "dec.s %0!",
      "dec.p.s %0!",
    #else
      "\314\376",
      "\314\224\376",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "movs %0!",
      "movs.p %0!",
    #else
      "movs\261",
      "movs\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "cmps %0!",
      "cmps.p %0!",
    #else
      "cmps\261",
      "cmps\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "fill %0!",
      "fill.p %0!",
    #else
      "fill\261",
      "fill\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "halt %0!",
      "halt.p %0!",
    #else
      "h\222\261",
      "h\222\224\261",
    #endif
    1-1, 1-0
  },
  {
    #ifdef SCPACK
      "bounds %0!",
      "bounds.p %0!",
    #else
      "\351\261",
      "\351\224\261",
    #endif
    1-1, 1-0
  },

  /* ----- */
  { NULL, NULL, 0 }
};
